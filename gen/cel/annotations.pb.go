// CEL-based validation for proto fields.
//
// Provides declarative validation with good DX:
//   Types > Shorthand > Raw CEL
//
// https://github.com/hexfusion/fray

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: annotations.proto

package cel

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Well-known formats with hardened validation.
// These map to specific regex patterns and/or validation functions.
type Format int32

const (
	Format_FORMAT_UNSPECIFIED Format = 0
	// Network/Internet
	Format_EMAIL    Format = 1 // RFC 5322 email address
	Format_URI      Format = 2 // RFC 3986 URI
	Format_URI_REF  Format = 3 // RFC 3986 URI reference
	Format_HOSTNAME Format = 4 // RFC 1123 hostname
	Format_IPV4     Format = 5 // IPv4 address
	Format_IPV6     Format = 6 // IPv6 address
	Format_IP       Format = 7 // IPv4 or IPv6
	// Identifiers
	Format_UUID    Format = 10 // RFC 4122 UUID (any version)
	Format_UUID_V4 Format = 11 // UUID version 4
	// Kubernetes/Cloud Native
	Format_DNS_LABEL      Format = 20 // RFC 1123 DNS label (max 63 chars, lowercase)
	Format_DNS_SUBDOMAIN  Format = 21 // RFC 1123 DNS subdomain (max 253 chars)
	Format_QUALIFIED_NAME Format = 22 // Kubernetes qualified name (prefix/name)
	// Container/OCI
	Format_IMAGE_REF    Format = 30 // Container image reference
	Format_IMAGE_TAG    Format = 31 // Container image tag
	Format_IMAGE_DIGEST Format = 32 // Container image digest (sha256:...)
	// Time
	Format_DATE     Format = 40 // RFC 3339 date (YYYY-MM-DD)
	Format_DATETIME Format = 41 // RFC 3339 datetime
	Format_DURATION Format = 42 // Duration string (1h30m, etc.)
	// Versioning
	Format_SEMVER Format = 50 // Semantic version (v1.2.3)
	// Security
	Format_BASE64 Format = 60 // Base64 encoded string
	Format_PEM    Format = 61 // PEM encoded certificate/key
)

// Enum value maps for Format.
var (
	Format_name = map[int32]string{
		0:  "FORMAT_UNSPECIFIED",
		1:  "EMAIL",
		2:  "URI",
		3:  "URI_REF",
		4:  "HOSTNAME",
		5:  "IPV4",
		6:  "IPV6",
		7:  "IP",
		10: "UUID",
		11: "UUID_V4",
		20: "DNS_LABEL",
		21: "DNS_SUBDOMAIN",
		22: "QUALIFIED_NAME",
		30: "IMAGE_REF",
		31: "IMAGE_TAG",
		32: "IMAGE_DIGEST",
		40: "DATE",
		41: "DATETIME",
		42: "DURATION",
		50: "SEMVER",
		60: "BASE64",
		61: "PEM",
	}
	Format_value = map[string]int32{
		"FORMAT_UNSPECIFIED": 0,
		"EMAIL":              1,
		"URI":                2,
		"URI_REF":            3,
		"HOSTNAME":           4,
		"IPV4":               5,
		"IPV6":               6,
		"IP":                 7,
		"UUID":               10,
		"UUID_V4":            11,
		"DNS_LABEL":          20,
		"DNS_SUBDOMAIN":      21,
		"QUALIFIED_NAME":     22,
		"IMAGE_REF":          30,
		"IMAGE_TAG":          31,
		"IMAGE_DIGEST":       32,
		"DATE":               40,
		"DATETIME":           41,
		"DURATION":           42,
		"SEMVER":             50,
		"BASE64":             60,
		"PEM":                61,
	}
)

func (x Format) Enum() *Format {
	p := new(Format)
	*p = x
	return p
}

func (x Format) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Format) Descriptor() protoreflect.EnumDescriptor {
	return file_annotations_proto_enumTypes[0].Descriptor()
}

func (Format) Type() protoreflect.EnumType {
	return &file_annotations_proto_enumTypes[0]
}

func (x Format) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Format.Descriptor instead.
func (Format) EnumDescriptor() ([]byte, []int) {
	return file_annotations_proto_rawDescGZIP(), []int{0}
}

type FieldRules struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Well-known format types. Best DX - just declare the type.
	//
	// Example:
	//
	//	string email = 1 [(cel.field).format = EMAIL];
	//	string name = 2 [(cel.field).format = DNS_LABEL];
	Format *Format `protobuf:"varint,10,opt,name=format,proto3,enum=cel.Format,oneof" json:"format,omitempty"`
	// Shorthand validators. Good DX - common constraints.
	Required bool    `protobuf:"varint,11,opt,name=required,proto3" json:"required,omitempty"`                 // Must be set/non-empty
	Min      *int64  `protobuf:"varint,12,opt,name=min,proto3,oneof" json:"min,omitempty"`                     // Numeric minimum (inclusive)
	Max      *int64  `protobuf:"varint,13,opt,name=max,proto3,oneof" json:"max,omitempty"`                     // Numeric maximum (inclusive)
	MinLen   *int64  `protobuf:"varint,14,opt,name=min_len,json=minLen,proto3,oneof" json:"min_len,omitempty"` // Min length (string/bytes/list)
	MaxLen   *int64  `protobuf:"varint,15,opt,name=max_len,json=maxLen,proto3,oneof" json:"max_len,omitempty"` // Max length (string/bytes/list)
	Pattern  *string `protobuf:"bytes,16,opt,name=pattern,proto3,oneof" json:"pattern,omitempty"`              // Regex pattern for strings
	// Raw CEL validation rules. Fallback for custom logic.
	// Variable 'this' refers to the field value.
	//
	// Example:
	//
	//	int32 port = 1 [(cel.field).validate = {
	//	  expr: "this >= 1024 && this <= 65535",
	//	  message: "port must be in unprivileged range"
	//	}];
	Validate []*Rule `protobuf:"bytes,17,rep,name=validate,proto3" json:"validate,omitempty"`
	// CEL rules comparing new value to old value.
	// Variables: 'this' (new), 'oldSelf' (previous)
	//
	// Example:
	//
	//	string version = 1 [(cel.field).transition = {
	//	  expr: "this >= oldSelf",
	//	  message: "version cannot be downgraded"
	//	}];
	Transition []*Rule `protobuf:"bytes,20,rep,name=transition,proto3" json:"transition,omitempty"`
	// Field cannot change after creation.
	//
	// Example:
	//
	//	string id = 1 [(cel.field).immutable = true];
	Immutable bool `protobuf:"varint,21,opt,name=immutable,proto3" json:"immutable,omitempty"`
	// State machine transitions for enum fields.
	//
	// Example:
	//
	//	Status status = 1 [(cel.field).transitions = {
	//	  rules: [
	//	    { from: ["PENDING"], to: ["ACTIVE", "CANCELLED"] },
	//	    { from: ["ACTIVE"], to: ["COMPLETED", "FAILED"] }
	//	  ],
	//	  deny_unlisted: true
	//	}];
	Transitions   *StateTransitions `protobuf:"bytes,22,opt,name=transitions,proto3,oneof" json:"transitions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FieldRules) Reset() {
	*x = FieldRules{}
	mi := &file_annotations_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FieldRules) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FieldRules) ProtoMessage() {}

func (x *FieldRules) ProtoReflect() protoreflect.Message {
	mi := &file_annotations_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FieldRules.ProtoReflect.Descriptor instead.
func (*FieldRules) Descriptor() ([]byte, []int) {
	return file_annotations_proto_rawDescGZIP(), []int{0}
}

func (x *FieldRules) GetFormat() Format {
	if x != nil && x.Format != nil {
		return *x.Format
	}
	return Format_FORMAT_UNSPECIFIED
}

func (x *FieldRules) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *FieldRules) GetMin() int64 {
	if x != nil && x.Min != nil {
		return *x.Min
	}
	return 0
}

func (x *FieldRules) GetMax() int64 {
	if x != nil && x.Max != nil {
		return *x.Max
	}
	return 0
}

func (x *FieldRules) GetMinLen() int64 {
	if x != nil && x.MinLen != nil {
		return *x.MinLen
	}
	return 0
}

func (x *FieldRules) GetMaxLen() int64 {
	if x != nil && x.MaxLen != nil {
		return *x.MaxLen
	}
	return 0
}

func (x *FieldRules) GetPattern() string {
	if x != nil && x.Pattern != nil {
		return *x.Pattern
	}
	return ""
}

func (x *FieldRules) GetValidate() []*Rule {
	if x != nil {
		return x.Validate
	}
	return nil
}

func (x *FieldRules) GetTransition() []*Rule {
	if x != nil {
		return x.Transition
	}
	return nil
}

func (x *FieldRules) GetImmutable() bool {
	if x != nil {
		return x.Immutable
	}
	return false
}

func (x *FieldRules) GetTransitions() *StateTransitions {
	if x != nil {
		return x.Transitions
	}
	return nil
}

// Rule defines a CEL expression with error message.
type Rule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional identifier for the rule (for error reporting).
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// CEL expression that must evaluate to true.
	// Variables available: 'this' (new value), 'oldSelf' (previous value)
	Expr string `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	// Error message when rule fails.
	Message       string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Rule) Reset() {
	*x = Rule{}
	mi := &file_annotations_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rule) ProtoMessage() {}

func (x *Rule) ProtoReflect() protoreflect.Message {
	mi := &file_annotations_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rule.ProtoReflect.Descriptor instead.
func (*Rule) Descriptor() ([]byte, []int) {
	return file_annotations_proto_rawDescGZIP(), []int{1}
}

func (x *Rule) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Rule) GetExpr() string {
	if x != nil {
		return x.Expr
	}
	return ""
}

func (x *Rule) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// StateTransitions defines valid state changes for enum fields.
type StateTransitions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of allowed transitions.
	Rules []*StateTransition `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	// If true, any transition not explicitly listed is denied.
	// If false, unlisted transitions are allowed.
	DenyUnlisted  bool `protobuf:"varint,2,opt,name=deny_unlisted,json=denyUnlisted,proto3" json:"deny_unlisted,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StateTransitions) Reset() {
	*x = StateTransitions{}
	mi := &file_annotations_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StateTransitions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StateTransitions) ProtoMessage() {}

func (x *StateTransitions) ProtoReflect() protoreflect.Message {
	mi := &file_annotations_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StateTransitions.ProtoReflect.Descriptor instead.
func (*StateTransitions) Descriptor() ([]byte, []int) {
	return file_annotations_proto_rawDescGZIP(), []int{2}
}

func (x *StateTransitions) GetRules() []*StateTransition {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *StateTransitions) GetDenyUnlisted() bool {
	if x != nil {
		return x.DenyUnlisted
	}
	return false
}

// StateTransition defines a single allowed transition.
type StateTransition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source states (enum value names).
	From []string `protobuf:"bytes,1,rep,name=from,proto3" json:"from,omitempty"`
	// Target states (enum value names).
	To            []string `protobuf:"bytes,2,rep,name=to,proto3" json:"to,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StateTransition) Reset() {
	*x = StateTransition{}
	mi := &file_annotations_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StateTransition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StateTransition) ProtoMessage() {}

func (x *StateTransition) ProtoReflect() protoreflect.Message {
	mi := &file_annotations_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StateTransition.ProtoReflect.Descriptor instead.
func (*StateTransition) Descriptor() ([]byte, []int) {
	return file_annotations_proto_rawDescGZIP(), []int{3}
}

func (x *StateTransition) GetFrom() []string {
	if x != nil {
		return x.From
	}
	return nil
}

func (x *StateTransition) GetTo() []string {
	if x != nil {
		return x.To
	}
	return nil
}

type MessageRules struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CEL validation rules for the entire message.
	// Variable 'self' refers to the message.
	//
	// Example:
	//
	//	option (cel.message).validate = {
	//	  expr: "has(self.email) || has(self.phone)",
	//	  message: "must provide email or phone"
	//	};
	Validate []*Rule `protobuf:"bytes,1,rep,name=validate,proto3" json:"validate,omitempty"`
	// CEL transition rules for the entire message.
	// Variables: 'self' (new), 'oldSelf' (previous)
	// Only evaluated on UPDATE operations.
	//
	// Example:
	//
	//	option (cel.message).transition = {
	//	  expr: "self.version > oldSelf.version",
	//	  message: "version must increase on update"
	//	};
	Transition    []*Rule `protobuf:"bytes,2,rep,name=transition,proto3" json:"transition,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MessageRules) Reset() {
	*x = MessageRules{}
	mi := &file_annotations_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MessageRules) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageRules) ProtoMessage() {}

func (x *MessageRules) ProtoReflect() protoreflect.Message {
	mi := &file_annotations_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageRules.ProtoReflect.Descriptor instead.
func (*MessageRules) Descriptor() ([]byte, []int) {
	return file_annotations_proto_rawDescGZIP(), []int{4}
}

func (x *MessageRules) GetValidate() []*Rule {
	if x != nil {
		return x.Validate
	}
	return nil
}

func (x *MessageRules) GetTransition() []*Rule {
	if x != nil {
		return x.Transition
	}
	return nil
}

var file_annotations_proto_extTypes = []protoimpl.ExtensionInfo{
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*FieldRules)(nil),
		Field:         1160,
		Name:          "cel.field",
		Tag:           "bytes,1160,opt,name=field",
		Filename:      "annotations.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MessageOptions)(nil),
		ExtensionType: (*MessageRules)(nil),
		Field:         1161,
		Name:          "cel.message",
		Tag:           "bytes,1161,opt,name=message",
		Filename:      "annotations.proto",
	},
}

// Extension fields to descriptorpb.FieldOptions.
var (
	// optional cel.FieldRules field = 1160;
	E_Field = &file_annotations_proto_extTypes[0]
)

// Extension fields to descriptorpb.MessageOptions.
var (
	// optional cel.MessageRules message = 1161;
	E_Message = &file_annotations_proto_extTypes[1]
)

var File_annotations_proto protoreflect.FileDescriptor

const file_annotations_proto_rawDesc = "" +
	"\n" +
	"\x11annotations.proto\x12\x03cel\x1a google/protobuf/descriptor.proto\"\xd8\x03\n" +
	"\n" +
	"FieldRules\x12(\n" +
	"\x06format\x18\n" +
	" \x01(\x0e2\v.cel.FormatH\x00R\x06format\x88\x01\x01\x12\x1a\n" +
	"\brequired\x18\v \x01(\bR\brequired\x12\x15\n" +
	"\x03min\x18\f \x01(\x03H\x01R\x03min\x88\x01\x01\x12\x15\n" +
	"\x03max\x18\r \x01(\x03H\x02R\x03max\x88\x01\x01\x12\x1c\n" +
	"\amin_len\x18\x0e \x01(\x03H\x03R\x06minLen\x88\x01\x01\x12\x1c\n" +
	"\amax_len\x18\x0f \x01(\x03H\x04R\x06maxLen\x88\x01\x01\x12\x1d\n" +
	"\apattern\x18\x10 \x01(\tH\x05R\apattern\x88\x01\x01\x12%\n" +
	"\bvalidate\x18\x11 \x03(\v2\t.cel.RuleR\bvalidate\x12)\n" +
	"\n" +
	"transition\x18\x14 \x03(\v2\t.cel.RuleR\n" +
	"transition\x12\x1c\n" +
	"\timmutable\x18\x15 \x01(\bR\timmutable\x12<\n" +
	"\vtransitions\x18\x16 \x01(\v2\x15.cel.StateTransitionsH\x06R\vtransitions\x88\x01\x01B\t\n" +
	"\a_formatB\x06\n" +
	"\x04_minB\x06\n" +
	"\x04_maxB\n" +
	"\n" +
	"\b_min_lenB\n" +
	"\n" +
	"\b_max_lenB\n" +
	"\n" +
	"\b_patternB\x0e\n" +
	"\f_transitions\"D\n" +
	"\x04Rule\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04expr\x18\x02 \x01(\tR\x04expr\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"c\n" +
	"\x10StateTransitions\x12*\n" +
	"\x05rules\x18\x01 \x03(\v2\x14.cel.StateTransitionR\x05rules\x12#\n" +
	"\rdeny_unlisted\x18\x02 \x01(\bR\fdenyUnlisted\"5\n" +
	"\x0fStateTransition\x12\x12\n" +
	"\x04from\x18\x01 \x03(\tR\x04from\x12\x0e\n" +
	"\x02to\x18\x02 \x03(\tR\x02to\"`\n" +
	"\fMessageRules\x12%\n" +
	"\bvalidate\x18\x01 \x03(\v2\t.cel.RuleR\bvalidate\x12)\n" +
	"\n" +
	"transition\x18\x02 \x03(\v2\t.cel.RuleR\n" +
	"transition*\xaf\x02\n" +
	"\x06Format\x12\x16\n" +
	"\x12FORMAT_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05EMAIL\x10\x01\x12\a\n" +
	"\x03URI\x10\x02\x12\v\n" +
	"\aURI_REF\x10\x03\x12\f\n" +
	"\bHOSTNAME\x10\x04\x12\b\n" +
	"\x04IPV4\x10\x05\x12\b\n" +
	"\x04IPV6\x10\x06\x12\x06\n" +
	"\x02IP\x10\a\x12\b\n" +
	"\x04UUID\x10\n" +
	"\x12\v\n" +
	"\aUUID_V4\x10\v\x12\r\n" +
	"\tDNS_LABEL\x10\x14\x12\x11\n" +
	"\rDNS_SUBDOMAIN\x10\x15\x12\x12\n" +
	"\x0eQUALIFIED_NAME\x10\x16\x12\r\n" +
	"\tIMAGE_REF\x10\x1e\x12\r\n" +
	"\tIMAGE_TAG\x10\x1f\x12\x10\n" +
	"\fIMAGE_DIGEST\x10 \x12\b\n" +
	"\x04DATE\x10(\x12\f\n" +
	"\bDATETIME\x10)\x12\f\n" +
	"\bDURATION\x10*\x12\n" +
	"\n" +
	"\x06SEMVER\x102\x12\n" +
	"\n" +
	"\x06BASE64\x10<\x12\a\n" +
	"\x03PEM\x10=:E\n" +
	"\x05field\x12\x1d.google.protobuf.FieldOptions\x18\x88\t \x01(\v2\x0f.cel.FieldRulesR\x05field:M\n" +
	"\amessage\x12\x1f.google.protobuf.MessageOptions\x18\x89\t \x01(\v2\x11.cel.MessageRulesR\amessageB'Z%github.com/hexfusion/fray/gen/cel;celb\x06proto3"

var (
	file_annotations_proto_rawDescOnce sync.Once
	file_annotations_proto_rawDescData []byte
)

func file_annotations_proto_rawDescGZIP() []byte {
	file_annotations_proto_rawDescOnce.Do(func() {
		file_annotations_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_annotations_proto_rawDesc), len(file_annotations_proto_rawDesc)))
	})
	return file_annotations_proto_rawDescData
}

var file_annotations_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_annotations_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_annotations_proto_goTypes = []any{
	(Format)(0),                         // 0: cel.Format
	(*FieldRules)(nil),                  // 1: cel.FieldRules
	(*Rule)(nil),                        // 2: cel.Rule
	(*StateTransitions)(nil),            // 3: cel.StateTransitions
	(*StateTransition)(nil),             // 4: cel.StateTransition
	(*MessageRules)(nil),                // 5: cel.MessageRules
	(*descriptorpb.FieldOptions)(nil),   // 6: google.protobuf.FieldOptions
	(*descriptorpb.MessageOptions)(nil), // 7: google.protobuf.MessageOptions
}
var file_annotations_proto_depIdxs = []int32{
	0,  // 0: cel.FieldRules.format:type_name -> cel.Format
	2,  // 1: cel.FieldRules.validate:type_name -> cel.Rule
	2,  // 2: cel.FieldRules.transition:type_name -> cel.Rule
	3,  // 3: cel.FieldRules.transitions:type_name -> cel.StateTransitions
	4,  // 4: cel.StateTransitions.rules:type_name -> cel.StateTransition
	2,  // 5: cel.MessageRules.validate:type_name -> cel.Rule
	2,  // 6: cel.MessageRules.transition:type_name -> cel.Rule
	6,  // 7: cel.field:extendee -> google.protobuf.FieldOptions
	7,  // 8: cel.message:extendee -> google.protobuf.MessageOptions
	1,  // 9: cel.field:type_name -> cel.FieldRules
	5,  // 10: cel.message:type_name -> cel.MessageRules
	11, // [11:11] is the sub-list for method output_type
	11, // [11:11] is the sub-list for method input_type
	9,  // [9:11] is the sub-list for extension type_name
	7,  // [7:9] is the sub-list for extension extendee
	0,  // [0:7] is the sub-list for field type_name
}

func init() { file_annotations_proto_init() }
func file_annotations_proto_init() {
	if File_annotations_proto != nil {
		return
	}
	file_annotations_proto_msgTypes[0].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_annotations_proto_rawDesc), len(file_annotations_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   5,
			NumExtensions: 2,
			NumServices:   0,
		},
		GoTypes:           file_annotations_proto_goTypes,
		DependencyIndexes: file_annotations_proto_depIdxs,
		EnumInfos:         file_annotations_proto_enumTypes,
		MessageInfos:      file_annotations_proto_msgTypes,
		ExtensionInfos:    file_annotations_proto_extTypes,
	}.Build()
	File_annotations_proto = out.File
	file_annotations_proto_goTypes = nil
	file_annotations_proto_depIdxs = nil
}
