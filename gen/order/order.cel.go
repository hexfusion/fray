// Code generated by protoc-gen-cel. DO NOT EDIT.
// source: order.proto

package order

import (
	"fmt"
	"regexp"

	"github.com/hexfusion/fray/pkg/cel"
)

// pre-compiled patterns
var (
	patternSku = regexp.MustCompile(`^[A-Z0-9-]+$`)
)

var (
	_ = fmt.Errorf
	_ = cel.EvalTransitionRule
)

// Validate checks validation rules for Order.
func (x *Order) Validate() error {
	if x == nil {
		return nil
	}

	// cel: size(self.items) > 0
	if err := cel.EvalProtoValidateRule("size(self.items) > 0", x); err != nil {
		return fmt.Errorf("Order: order must have at least one item")
	}

	if x.Id == "" {
		return fmt.Errorf("Id is required")
	}
	if err := cel.ValidateUUID(x.Id); err != nil {
		return fmt.Errorf("Id: %w", err)
	}
	if x.CustomerId == "" {
		return fmt.Errorf("CustomerId is required")
	}
	if err := cel.ValidateUUID(x.CustomerId); err != nil {
		return fmt.Errorf("CustomerId: %w", err)
	}
	if x.CustomerEmail == "" {
		return fmt.Errorf("CustomerEmail is required")
	}
	if err := cel.ValidateEmail(x.CustomerEmail); err != nil {
		return fmt.Errorf("CustomerEmail: %w", err)
	}
	if x.TotalCents < 0 {
		return fmt.Errorf("TotalCents must be >= %d", 0)
	}
	if x.Version < 1 {
		return fmt.Errorf("Version must be >= %d", 1)
	}
	if x.CreatedAt != "" {
		if err := cel.ValidateDatetime(x.CreatedAt); err != nil {
			return fmt.Errorf("CreatedAt: %w", err)
		}
	}
	if x.UpdatedAt != "" {
		if err := cel.ValidateDatetime(x.UpdatedAt); err != nil {
			return fmt.Errorf("UpdatedAt: %w", err)
		}
	}
	if x.ShippingZone != "" {
		if err := cel.ValidateDNSSubdomain(x.ShippingZone); err != nil {
			return fmt.Errorf("ShippingZone: %w", err)
		}
	}
	for i, item := range x.Items {
		if err := item.Validate(); err != nil {
			return fmt.Errorf("Items[%d]: %w", i, err)
		}
	}
	return nil
}

// ValidateUpdate checks transition rules against old value.
func (x *Order) ValidateUpdate(old *Order) error {
	if err := x.Validate(); err != nil {
		return err
	}
	if old == nil {
		return nil
	}

	// cel: self.version > oldSelf.version
	if err := cel.EvalProtoTransitionRule("self.version > oldSelf.version", x, old); err != nil {
		return fmt.Errorf("Order: version must increase on update")
	}

	if x.Id != old.Id {
		return fmt.Errorf("Id is immutable: cannot change from %q to %q", old.Id, x.Id)
	}
	if x.CustomerId != old.CustomerId {
		return fmt.Errorf("CustomerId is immutable: cannot change from %q to %q", old.CustomerId, x.CustomerId)
	}
	// state transitions for Status
	{
		oldState := old.Status.String()
		newState := x.Status.String()
		if oldState != newState {
			allowed := false
			// []string{"PENDING"} -> []string{"CONFIRMED", "CANCELLED"}
			for _, from := range []string{"PENDING"} {
				if oldState == from {
					for _, to := range []string{"CONFIRMED", "CANCELLED"} {
						if newState == to {
							allowed = true
							break
						}
					}
				}
				if allowed {
					break
				}
			}
			// []string{"CONFIRMED"} -> []string{"PROCESSING", "CANCELLED"}
			for _, from := range []string{"CONFIRMED"} {
				if oldState == from {
					for _, to := range []string{"PROCESSING", "CANCELLED"} {
						if newState == to {
							allowed = true
							break
						}
					}
				}
				if allowed {
					break
				}
			}
			// []string{"PROCESSING"} -> []string{"SHIPPED", "CANCELLED"}
			for _, from := range []string{"PROCESSING"} {
				if oldState == from {
					for _, to := range []string{"SHIPPED", "CANCELLED"} {
						if newState == to {
							allowed = true
							break
						}
					}
				}
				if allowed {
					break
				}
			}
			// []string{"SHIPPED"} -> []string{"DELIVERED", "REFUNDED"}
			for _, from := range []string{"SHIPPED"} {
				if oldState == from {
					for _, to := range []string{"DELIVERED", "REFUNDED"} {
						if newState == to {
							allowed = true
							break
						}
					}
				}
				if allowed {
					break
				}
			}
			// []string{"DELIVERED"} -> []string{"REFUNDED"}
			for _, from := range []string{"DELIVERED"} {
				if oldState == from {
					for _, to := range []string{"REFUNDED"} {
						if newState == to {
							allowed = true
							break
						}
					}
				}
				if allowed {
					break
				}
			}
			if !allowed {
				return fmt.Errorf("Status: invalid transition from %s to %s", oldState, newState)
			}
		}
	}
	// cel: this >= oldSelf
	if err := cel.EvalTransitionRule("this >= oldSelf", x.TotalCents, old.TotalCents); err != nil {
		return fmt.Errorf("TotalCents: total can only increase")
	}
	if x.CreatedAt != old.CreatedAt {
		return fmt.Errorf("CreatedAt is immutable: cannot change from %q to %q", old.CreatedAt, x.CreatedAt)
	}
	return nil
}

// Validate checks validation rules for OrderItem.
func (x *OrderItem) Validate() error {
	if x == nil {
		return nil
	}

	if x.ProductId == "" {
		return fmt.Errorf("ProductId is required")
	}
	if err := cel.ValidateUUID(x.ProductId); err != nil {
		return fmt.Errorf("ProductId: %w", err)
	}
	if x.Quantity < 1 {
		return fmt.Errorf("Quantity must be >= %d", 1)
	}
	if x.Quantity > 1000 {
		return fmt.Errorf("Quantity must be <= %d", 1000)
	}
	if x.PriceCents < 0 {
		return fmt.Errorf("PriceCents must be >= %d", 0)
	}
	if x.Sku == "" {
		return fmt.Errorf("Sku is required")
	}
	if len(x.Sku) < 3 {
		return fmt.Errorf("Sku must have at least %d elements/characters", 3)
	}
	if len(x.Sku) > 20 {
		return fmt.Errorf("Sku must have at most %d elements/characters", 20)
	}
	if !patternSku.MatchString(x.Sku) {
		return fmt.Errorf("Sku must match pattern")
	}
	return nil
}

// ValidateUpdate checks transition rules against old value.
func (x *OrderItem) ValidateUpdate(old *OrderItem) error {
	if err := x.Validate(); err != nil {
		return err
	}
	if old == nil {
		return nil
	}

	if x.ProductId != old.ProductId {
		return fmt.Errorf("ProductId is immutable: cannot change from %q to %q", old.ProductId, x.ProductId)
	}
	return nil
}

// Validate checks validation rules for CreateOrderRequest.
func (x *CreateOrderRequest) Validate() error {
	if x == nil {
		return nil
	}

	if x.Order != nil {
		if err := x.Order.Validate(); err != nil {
			return fmt.Errorf("Order: %w", err)
		}
	}
	return nil
}

// ValidateUpdate checks transition rules against old value.
func (x *CreateOrderRequest) ValidateUpdate(old *CreateOrderRequest) error {
	if err := x.Validate(); err != nil {
		return err
	}
	if old == nil {
		return nil
	}

	return nil
}

// Validate checks validation rules for CreateOrderResponse.
func (x *CreateOrderResponse) Validate() error {
	if x == nil {
		return nil
	}

	if x.Order != nil {
		if err := x.Order.Validate(); err != nil {
			return fmt.Errorf("Order: %w", err)
		}
	}
	return nil
}

// ValidateUpdate checks transition rules against old value.
func (x *CreateOrderResponse) ValidateUpdate(old *CreateOrderResponse) error {
	if err := x.Validate(); err != nil {
		return err
	}
	if old == nil {
		return nil
	}

	return nil
}

// Validate checks validation rules for GetOrderRequest.
func (x *GetOrderRequest) Validate() error {
	if x == nil {
		return nil
	}

	if x.Id == "" {
		return fmt.Errorf("Id is required")
	}
	if err := cel.ValidateUUID(x.Id); err != nil {
		return fmt.Errorf("Id: %w", err)
	}
	return nil
}

// ValidateUpdate checks transition rules against old value.
func (x *GetOrderRequest) ValidateUpdate(old *GetOrderRequest) error {
	if err := x.Validate(); err != nil {
		return err
	}
	if old == nil {
		return nil
	}

	return nil
}

// Validate checks validation rules for GetOrderResponse.
func (x *GetOrderResponse) Validate() error {
	if x == nil {
		return nil
	}

	if x.Order != nil {
		if err := x.Order.Validate(); err != nil {
			return fmt.Errorf("Order: %w", err)
		}
	}
	return nil
}

// ValidateUpdate checks transition rules against old value.
func (x *GetOrderResponse) ValidateUpdate(old *GetOrderResponse) error {
	if err := x.Validate(); err != nil {
		return err
	}
	if old == nil {
		return nil
	}

	return nil
}

// Validate checks validation rules for UpdateOrderRequest.
func (x *UpdateOrderRequest) Validate() error {
	if x == nil {
		return nil
	}

	if x.Order != nil {
		if err := x.Order.Validate(); err != nil {
			return fmt.Errorf("Order: %w", err)
		}
	}
	return nil
}

// ValidateUpdate checks transition rules against old value.
func (x *UpdateOrderRequest) ValidateUpdate(old *UpdateOrderRequest) error {
	if err := x.Validate(); err != nil {
		return err
	}
	if old == nil {
		return nil
	}

	return nil
}

// Validate checks validation rules for UpdateOrderResponse.
func (x *UpdateOrderResponse) Validate() error {
	if x == nil {
		return nil
	}

	if x.Order != nil {
		if err := x.Order.Validate(); err != nil {
			return fmt.Errorf("Order: %w", err)
		}
	}
	return nil
}

// ValidateUpdate checks transition rules against old value.
func (x *UpdateOrderResponse) ValidateUpdate(old *UpdateOrderResponse) error {
	if err := x.Validate(); err != nil {
		return err
	}
	if old == nil {
		return nil
	}

	return nil
}

// Validate checks validation rules for ListOrdersRequest.
func (x *ListOrdersRequest) Validate() error {
	if x == nil {
		return nil
	}

	if x.PageSize < 1 {
		return fmt.Errorf("PageSize must be >= %d", 1)
	}
	if x.PageSize > 100 {
		return fmt.Errorf("PageSize must be <= %d", 100)
	}
	return nil
}

// ValidateUpdate checks transition rules against old value.
func (x *ListOrdersRequest) ValidateUpdate(old *ListOrdersRequest) error {
	if err := x.Validate(); err != nil {
		return err
	}
	if old == nil {
		return nil
	}

	return nil
}

// Validate checks validation rules for ListOrdersResponse.
func (x *ListOrdersResponse) Validate() error {
	if x == nil {
		return nil
	}

	for i, item := range x.Orders {
		if err := item.Validate(); err != nil {
			return fmt.Errorf("Orders[%d]: %w", i, err)
		}
	}
	return nil
}

// ValidateUpdate checks transition rules against old value.
func (x *ListOrdersResponse) ValidateUpdate(old *ListOrdersResponse) error {
	if err := x.Validate(); err != nil {
		return err
	}
	if old == nil {
		return nil
	}

	return nil
}
