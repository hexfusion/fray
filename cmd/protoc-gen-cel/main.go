// protoc-gen-cel generates transition validation code from proto annotations.
//
// This plugin complements protovalidate by adding update/transition validation
// that requires comparing new values to old values (oldSelf).
//
// Usage:
//
//	protoc --cel_out=./gen --cel_opt=paths=source_relative *.proto
//
// Or with buf:
//
//	plugins:
//	  - local: protoc-gen-cel
//	    out: gen
//	    opt: paths=source_relative
package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	celext "github.com/hexfusion/fray/gen/cel"
)

func main() {
	var flags flag.FlagSet

	opts := protogen.Options{
		ParamFunc: flags.Set,
	}

	opts.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if err := generateFile(gen, f); err != nil {
				return err
			}
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Messages) == 0 {
		return nil
	}
	if !fileHasCelAnnotations(file) {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + ".cel.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	patterns := collectPatterns(file)

	generateHeader(g, file)
	generateImports(g, patterns)

	for _, msg := range file.Messages {
		generateMessageValidation(g, msg, patterns)
	}

	return nil
}

func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-cel. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
}

func generateImports(g *protogen.GeneratedFile, patterns []patternInfo) {
	g.P("import (")
	g.P(`	"fmt"`)
	if len(patterns) > 0 {
		g.P(`	"regexp"`)
	}
	g.P()
	g.P(`	"github.com/hexfusion/fray/pkg/cel"`)
	g.P(")")
	g.P()

	if len(patterns) > 0 {
		g.P("// pre-compiled patterns")
		g.P("var (")
		for _, p := range patterns {
			g.P("	", p.varName, " = regexp.MustCompile(`", p.pattern, "`)")
		}
		g.P(")")
		g.P()
	}

	g.P("var (")
	g.P("	_ = fmt.Errorf")
	g.P("	_ = cel.EvalTransitionRule")
	g.P(")")
	g.P()
}

type patternInfo struct {
	varName string
	pattern string
}

func generateMessageValidation(g *protogen.GeneratedFile, msg *protogen.Message, patterns []patternInfo) {
	msgName := msg.GoIdent.GoName
	msgRules := getMessageRules(msg)

	g.P("// Validate checks validation rules for ", msgName, ".")
	g.P("func (x *", msgName, ") Validate() error {")
	g.P("	if x == nil {")
	g.P("		return nil")
	g.P("	}")
	g.P()

	if msgRules != nil && len(msgRules.Validate) > 0 {
		for _, rule := range msgRules.Validate {
			generateCELValidateCheck(g, rule, msgName)
		}
		g.P()
	}

	for _, field := range msg.Fields {
		generateFieldValidation(g, field, patterns)
	}

	// Validate nested message fields
	for _, field := range msg.Fields {
		generateNestedValidation(g, field)
	}

	g.P("	return nil")
	g.P("}")
	g.P()

	g.P("// ValidateUpdate checks transition rules against old value.")
	g.P("func (x *", msgName, ") ValidateUpdate(old *", msgName, ") error {")
	g.P("	if err := x.Validate(); err != nil {")
	g.P("		return err")
	g.P("	}")
	g.P("	if old == nil {")
	g.P("		return nil")
	g.P("	}")
	g.P()

	if msgRules != nil && len(msgRules.Transition) > 0 {
		for _, rule := range msgRules.Transition {
			generateCELTransitionCheck(g, rule, "x", "old", msgName, true)
		}
		g.P()
	}

	hasTransitionRules := false
	for _, field := range msg.Fields {
		rules := getFieldRules(field)
		if rules != nil && (rules.Immutable || len(rules.Transition) > 0 || rules.Transitions != nil) {
			hasTransitionRules = true
			break
		}
	}

	if hasTransitionRules {
		for _, field := range msg.Fields {
			generateFieldTransition(g, field)
		}
	}

	g.P("	return nil")
	g.P("}")
	g.P()

	for _, nested := range msg.Messages {
		generateMessageValidation(g, nested, patterns)
	}
}

func generateFieldTransition(g *protogen.GeneratedFile, field *protogen.Field) {
	rules := getFieldRules(field)
	if rules == nil {
		return
	}
	if !rules.Immutable && len(rules.Transition) == 0 && rules.Transitions == nil {
		return
	}

	fieldName := field.GoName
	newAccess := "x." + fieldName
	oldAccess := "old." + fieldName

	if rules.Immutable {
		generateImmutableCheck(g, field, fieldName, newAccess, oldAccess)
	}
	for _, rule := range rules.Transition {
		generateCELTransitionCheck(g, rule, newAccess, oldAccess, fieldName, false)
	}
	if rules.Transitions != nil && field.Enum != nil {
		generateStateMachineCheck(g, field, rules.Transitions, fieldName, newAccess, oldAccess)
	}
}

func generateImmutableCheck(g *protogen.GeneratedFile, field *protogen.Field, fieldName, newAccess, oldAccess string) {
	kind := field.Desc.Kind().String()
	switch kind {
	case "string":
		g.P(`	if `, newAccess, ` != `, oldAccess, ` {`)
		g.P(`		return fmt.Errorf("`, fieldName, ` is immutable: cannot change from %q to %q", `, oldAccess, `, `, newAccess, `)`)
		g.P(`	}`)
	case "bytes":
		g.P(`	if string(`, newAccess, `) != string(`, oldAccess, `) {`)
		g.P(`		return fmt.Errorf("`, fieldName, ` is immutable")`)
		g.P(`	}`)
	case "int32", "int64", "uint32", "uint64", "sint32", "sint64", "fixed32", "fixed64", "sfixed32", "sfixed64":
		g.P(`	if `, newAccess, ` != `, oldAccess, ` {`)
		g.P(`		return fmt.Errorf("`, fieldName, ` is immutable: cannot change from %d to %d", `, oldAccess, `, `, newAccess, `)`)
		g.P(`	}`)
	case "float", "double", "bool", "enum":
		g.P(`	if `, newAccess, ` != `, oldAccess, ` {`)
		g.P(`		return fmt.Errorf("`, fieldName, ` is immutable: cannot change from %v to %v", `, oldAccess, `, `, newAccess, `)`)
		g.P(`	}`)
	default:
		g.P(`	// TODO: immutable check for complex type `, kind)
	}
}

func generateCELTransitionCheck(g *protogen.GeneratedFile, rule *celext.Rule, newVar, oldVar, context string, isMessage bool) {
	if rule.Expr == "" {
		return
	}

	msg := rule.Message
	if msg == "" {
		msg = fmt.Sprintf("transition rule failed: %s", rule.Expr)
	}

	g.P(`	// cel: `, rule.Expr)

	expr := strings.ReplaceAll(rule.Expr, `\`, `\\`)
	expr = strings.ReplaceAll(expr, `"`, `\"`)

	if isMessage {
		g.P(`	if err := cel.EvalProtoTransitionRule("`, expr, `", x, old); err != nil {`)
	} else {
		g.P(`	if err := cel.EvalTransitionRule("`, expr, `", `, newVar, `, `, oldVar, `); err != nil {`)
	}
	g.P(`		return fmt.Errorf("`, context, `: `, msg, `")`)
	g.P(`	}`)
}

func generateFieldValidation(g *protogen.GeneratedFile, field *protogen.Field, patterns []patternInfo) {
	rules := getFieldRules(field)
	if rules == nil {
		return
	}

	fieldName := field.GoName
	fieldAccess := "x." + fieldName
	kind := field.Desc.Kind().String()

	if rules.Required {
		switch kind {
		case "string":
			g.P(`	if `, fieldAccess, ` == "" {`)
			g.P(`		return fmt.Errorf("`, fieldName, ` is required")`)
			g.P(`	}`)
		case "bytes":
			g.P(`	if len(`, fieldAccess, `) == 0 {`)
			g.P(`		return fmt.Errorf("`, fieldName, ` is required")`)
			g.P(`	}`)
		case "message":
			g.P(`	if `, fieldAccess, ` == nil {`)
			g.P(`		return fmt.Errorf("`, fieldName, ` is required")`)
			g.P(`	}`)
		}
	}

	if rules.Format != nil && *rules.Format != celext.Format_FORMAT_UNSPECIFIED {
		formatFunc := formatToFunc(*rules.Format)
		if formatFunc != "" {
			if !rules.Required && kind == "string" {
				g.P(`	if `, fieldAccess, ` != "" {`)
				g.P(`		if err := cel.`, formatFunc, `(`, fieldAccess, `); err != nil {`)
				g.P(`			return fmt.Errorf("`, fieldName, `: %w", err)`)
				g.P(`		}`)
				g.P(`	}`)
			} else {
				g.P(`	if err := cel.`, formatFunc, `(`, fieldAccess, `); err != nil {`)
				g.P(`		return fmt.Errorf("`, fieldName, `: %w", err)`)
				g.P(`	}`)
			}
		}
	}

	if rules.Min != nil {
		g.P(`	if `, fieldAccess, ` < `, *rules.Min, ` {`)
		g.P(`		return fmt.Errorf("`, fieldName, ` must be >= %d", `, *rules.Min, `)`)
		g.P(`	}`)
	}
	if rules.Max != nil {
		g.P(`	if `, fieldAccess, ` > `, *rules.Max, ` {`)
		g.P(`		return fmt.Errorf("`, fieldName, ` must be <= %d", `, *rules.Max, `)`)
		g.P(`	}`)
	}

	if rules.MinLen != nil {
		g.P(`	if len(`, fieldAccess, `) < `, *rules.MinLen, ` {`)
		g.P(`		return fmt.Errorf("`, fieldName, ` must have at least %d elements/characters", `, *rules.MinLen, `)`)
		g.P(`	}`)
	}
	if rules.MaxLen != nil {
		g.P(`	if len(`, fieldAccess, `) > `, *rules.MaxLen, ` {`)
		g.P(`		return fmt.Errorf("`, fieldName, ` must have at most %d elements/characters", `, *rules.MaxLen, `)`)
		g.P(`	}`)
	}

	if rules.Pattern != nil && *rules.Pattern != "" {
		varName := patternVarName(field)
		g.P(`	if !`, varName, `.MatchString(`, fieldAccess, `) {`)
		g.P(`		return fmt.Errorf("`, fieldName, ` must match pattern")`)
		g.P(`	}`)
	}

	for _, rule := range rules.Validate {
		generateCELValidateCheck(g, rule, fieldName)
	}
}

func generateNestedValidation(g *protogen.GeneratedFile, field *protogen.Field) {
	if field.Message == nil {
		return // Not a message type
	}
	// Skip map fields - they need special handling
	if field.Desc.IsMap() {
		return
	}

	fieldName := field.GoName
	fieldAccess := "x." + fieldName

	if field.Desc.IsList() {
		// Repeated message field
		g.P(`	for i, item := range `, fieldAccess, ` {`)
		g.P(`		if err := item.Validate(); err != nil {`)
		g.P(`			return fmt.Errorf("`, fieldName, `[%d]: %w", i, err)`)
		g.P(`		}`)
		g.P(`	}`)
	} else {
		// Singular message field
		g.P(`	if `, fieldAccess, ` != nil {`)
		g.P(`		if err := `, fieldAccess, `.Validate(); err != nil {`)
		g.P(`			return fmt.Errorf("`, fieldName, `: %w", err)`)
		g.P(`		}`)
		g.P(`	}`)
	}
}

func patternVarName(field *protogen.Field) string {
	return "pattern" + field.GoName
}

func collectPatterns(file *protogen.File) []patternInfo {
	var patterns []patternInfo
	for _, msg := range file.Messages {
		patterns = collectMessagePatterns(msg, patterns)
	}
	return patterns
}

func collectMessagePatterns(msg *protogen.Message, patterns []patternInfo) []patternInfo {
	for _, field := range msg.Fields {
		rules := getFieldRules(field)
		if rules != nil && rules.Pattern != nil && *rules.Pattern != "" {
			patterns = append(patterns, patternInfo{
				varName: patternVarName(field),
				pattern: *rules.Pattern,
			})
		}
	}
	for _, nested := range msg.Messages {
		patterns = collectMessagePatterns(nested, patterns)
	}
	return patterns
}

func generateCELValidateCheck(g *protogen.GeneratedFile, rule *celext.Rule, context string) {
	if rule.Expr == "" {
		return
	}

	msg := rule.Message
	if msg == "" {
		msg = fmt.Sprintf("validation failed: %s", rule.Expr)
	}

	g.P(`	// cel: `, rule.Expr)

	expr := strings.ReplaceAll(rule.Expr, `\`, `\\`)
	expr = strings.ReplaceAll(expr, `"`, `\"`)

	g.P(`	if err := cel.EvalProtoValidateRule("`, expr, `", x); err != nil {`)
	g.P(`		return fmt.Errorf("`, context, `: `, msg, `")`)
	g.P(`	}`)
}

func formatToFunc(f celext.Format) string {
	switch f {
	case celext.Format_EMAIL:
		return "ValidateEmail"
	case celext.Format_URI:
		return "ValidateURI"
	case celext.Format_URI_REF:
		return "ValidateURIRef"
	case celext.Format_HOSTNAME:
		return "ValidateHostname"
	case celext.Format_IPV4:
		return "ValidateIPv4"
	case celext.Format_IPV6:
		return "ValidateIPv6"
	case celext.Format_IP:
		return "ValidateIP"
	case celext.Format_UUID:
		return "ValidateUUID"
	case celext.Format_UUID_V4:
		return "ValidateUUIDv4"
	case celext.Format_DNS_LABEL:
		return "ValidateDNSLabel"
	case celext.Format_DNS_SUBDOMAIN:
		return "ValidateDNSSubdomain"
	case celext.Format_QUALIFIED_NAME:
		return "ValidateQualifiedName"
	case celext.Format_IMAGE_REF:
		return "ValidateImageRef"
	case celext.Format_IMAGE_TAG:
		return "ValidateImageTag"
	case celext.Format_IMAGE_DIGEST:
		return "ValidateImageDigest"
	case celext.Format_DATE:
		return "ValidateDate"
	case celext.Format_DATETIME:
		return "ValidateDatetime"
	case celext.Format_DURATION:
		return "ValidateDuration"
	case celext.Format_SEMVER:
		return "ValidateSemver"
	case celext.Format_BASE64:
		return "ValidateBase64"
	case celext.Format_PEM:
		return "ValidatePEM"
	default:
		return ""
	}
}

func generateStateMachineCheck(g *protogen.GeneratedFile, _ *protogen.Field, transitions *celext.StateTransitions, fieldName, newAccess, oldAccess string) {
	if len(transitions.Rules) == 0 && !transitions.DenyUnlisted {
		return
	}

	g.P(`	// state transitions for `, fieldName)
	g.P(`	{`)
	g.P(`		oldState := `, oldAccess, `.String()`)
	g.P(`		newState := `, newAccess, `.String()`)
	g.P(`		if oldState != newState {`)
	g.P(`			allowed := false`)

	for _, rule := range transitions.Rules {
		fromStates := formatStringSlice(rule.From)
		toStates := formatStringSlice(rule.To)
		g.P(`			// `, fromStates, ` -> `, toStates)
		g.P(`			for _, from := range `, fromStates, ` {`)
		g.P(`				if oldState == from {`)
		g.P(`					for _, to := range `, toStates, ` {`)
		g.P(`						if newState == to {`)
		g.P(`							allowed = true`)
		g.P(`							break`)
		g.P(`						}`)
		g.P(`					}`)
		g.P(`				}`)
		g.P(`				if allowed { break }`)
		g.P(`			}`)
	}

	if transitions.DenyUnlisted {
		g.P(`			if !allowed {`)
		g.P(`				return fmt.Errorf("`, fieldName, `: invalid transition from %s to %s", oldState, newState)`)
		g.P(`			}`)
	} else {
		g.P(`			_ = allowed`)
	}

	g.P(`		}`)
	g.P(`	}`)
}

func formatStringSlice(strs []string) string {
	if len(strs) == 0 {
		return "[]string{}"
	}
	quoted := make([]string, len(strs))
	for i, s := range strs {
		quoted[i] = fmt.Sprintf("%q", s)
	}
	return "[]string{" + strings.Join(quoted, ", ") + "}"
}

func getFieldRules(field *protogen.Field) *celext.FieldRules {
	opts := field.Desc.Options()
	if opts == nil {
		return nil
	}

	fieldOpts, ok := opts.(*descriptorpb.FieldOptions)
	if !ok || fieldOpts == nil {
		return nil
	}

	ext := proto.GetExtension(fieldOpts, celext.E_Field)
	if ext == nil {
		return nil
	}

	rules, ok := ext.(*celext.FieldRules)
	if !ok {
		return nil
	}

	return rules
}

func getMessageRules(msg *protogen.Message) *celext.MessageRules {
	opts := msg.Desc.Options()
	if opts == nil {
		return nil
	}

	msgOpts, ok := opts.(*descriptorpb.MessageOptions)
	if !ok || msgOpts == nil {
		return nil
	}

	ext := proto.GetExtension(msgOpts, celext.E_Message)
	if ext == nil {
		return nil
	}

	rules, ok := ext.(*celext.MessageRules)
	if !ok {
		return nil
	}

	return rules
}

func fileHasCelAnnotations(file *protogen.File) bool {
	for _, msg := range file.Messages {
		if messageHasCelAnnotations(msg) {
			return true
		}
	}
	return false
}

func messageHasCelAnnotations(msg *protogen.Message) bool {
	if getMessageRules(msg) != nil {
		return true
	}
	for _, field := range msg.Fields {
		if getFieldRules(field) != nil {
			return true
		}
	}
	for _, nested := range msg.Messages {
		if messageHasCelAnnotations(nested) {
			return true
		}
	}
	return false
}
